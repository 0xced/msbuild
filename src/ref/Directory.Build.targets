<Project>

  <PropertyGroup>
    <PackageLicenseUrl>http://go.microsoft.com/fwlink/?LinkId=329770</PackageLicenseUrl>
    <PackageProjectUrl>http://go.microsoft.com/fwlink/?LinkId=624683</PackageProjectUrl>
    <PackageIconUrl>https://go.microsoft.com/fwlink/?linkid=825694</PackageIconUrl>

    <!-- The package projects multi-target to netstandard1.3;net46;netstandard2.0.
         (The TargetFrameworks property isn't set in the common .props file because some of VS's tooling
         sniffs for that property directly in the project file).

          We target .NET Standard 1.3 with the reference assemblies in order to support single-binary portable
          tasks that can be loaded both on the full Framework and .NET Core versions of MSBuild.
    -->

    <!-- Here we override the framework selection logic so that the .NET Standard 1.3 version of the reference assembly project
         "references" the .NET Standard 2.0 version of the implementation.  The assembly isn't actually referenced, we just need
         GenAPI to update the source files for the reference assembly. -->
    <TargetFrameworkForSourceProject>$(TargetFramework)</TargetFrameworkForSourceProject>
    <TargetFrameworkForSourceProject Condition="'$(TargetFramework)' == 'netstandard1.3'">netstandard2.0</TargetFrameworkForSourceProject>
  </PropertyGroup>

  <ItemGroup>
    <!-- Reference the corresponding source project so that it will be built (and GenAPI will update the reference assembly source)
         before this project builds, but don't use the output in any way. -->
    <ProjectReference Include="$(ImplementationProject)" ReferenceOutputAssembly="false"
                      SetTargetFramework="TargetFramework=$(TargetFrameworkForSourceProject)" />
  </ItemGroup>

  <ItemGroup>
    <Compile Include="netstandard\$(AssemblyName).cs"
             Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' "/>

    <Compile Include="net\$(AssemblyName).cs"
         Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' "/>
    
    <None Include="$(RepoRoot)THIRDPARTYNOTICES.txt" Pack="true" PackagePath="notices" Visible="false"/>
    
    <TfmSpecificPackageFile Include="$(TargetPath)" Pack="True" PackagePath="lib/$(TargetFramework)" />
  </ItemGroup>
  
  <!-- Import parent targets -->
  <Import Project="..\Directory.Build.targets"/>

  <Target Name="GetNuGetPackageVersionEx" AfterTargets="GetBuildVersion">

    <!--
    This target is used to customize the versions generated by NerdBank.GitVersioning.  The $(PrereleaseVersion) is read from version.json and
    then the git commit height and build revision is appended.
    -->
    <PropertyGroup Condition=" '$(PrereleaseVersion)' != '' ">
      <BuildNumber>0</BuildNumber>
      <!-- Local builds always have a revision of -private -->
      <BuildRevision Condition="'$(BUILD_BUILDNUMBER)' == ''">private</BuildRevision>

      <!-- Official builds have an ID that is guaranteed to be unique. -->
      <BuildRevision Condition="'$(BUILD_BUILDNUMBER)' != ''">$(BUILD_BUILDNUMBER)</BuildRevision>

      <PrereleaseVersion Condition="'$(PrereleaseVersion)' != '' And '$(BuildVersionNumberComponent)' != ''">$(PrereleaseVersion)-$([System.Int32]::Parse($(BuildVersionNumberComponent)).ToString('D6'))-$(BuildRevision)</PrereleaseVersion>

      <!-- Override the NuGet package version provided by Nerdbank.GitVersioning -->
      <PackageVersion>$(MajorMinorVersion).$(BuildNumber)$(PrereleaseVersion)</PackageVersion>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(PrereleaseVersion)' == '' ">
      <PackageVersion>$(MajorMinorVersion).$(BuildNumber)</PackageVersion>
    </PropertyGroup>
  </Target>

</Project>
